@page "/"
@using GameCollectionManager.Client.Shared
@using GameCollectionManager.Shared.Models
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.AspNetCore.Authorization
@using System.IdentityModel.Tokens.Jwt
@implements IAsyncDisposable
@attribute [Authorize]
@inject HttpClient Http
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject IJSRuntime JSRuntime

<PageTitle>Game Collection</PageTitle>

<div class="full-height-container">
    <MudTabs Elevation="2" 
             Rounded="true" 
             ApplyEffectsToContainer="true" 
             PanelClass="pa-6" 
             Class="full-height-tabs" 
             @bind-ActivePanelIndex="_activeTabIndex">
        
        <MudTabPanel Text="Games" Class="full-height-panel">
            <div id="games-scroll-container" class="infinite-scroll-container">
                <MudDataGrid Items="@DisplayedGames" 
                             Dense="true" 
                             Hover="true" 
                             Bordered="true" 
                             Striped="true" 
                             Virtualize="false"
                             FixedHeader="true"
                             Height="100%"
                             Class="data-grid-with-fixed-header">
                    <ToolBarContent>
                        <MudText Typo="Typo.h6">Games Collection (@games.Count total)</MudText>
                        <MudSpacer />
                        <MudTextField @bind-Value="searchString" 
                                    Placeholder="Search" 
                                    Adornment="Adornment.Start"
                                    AdornmentIcon="@Icons.Material.Filled.Search" 
                                    IconSize="Size.Medium" 
                                    Class="mt-0 ml-4"
                                    Immediate="true"
                                    @bind-Value:after="OnSearchChanged" />
                        <MudSpacer />
                        <MudButton Color="Color.Primary"
                                   Variant="Variant.Filled"
                                   OnClick="OpenAddGameDialog"
                                   StartIcon="@Icons.Material.Filled.Add">
                            Add Game
                        </MudButton>
                    </ToolBarContent>
                    <Columns>
                        <PropertyColumn Property="x => x.name" Title="Title" />
                        <PropertyColumn Property="x => x.platforms" Title="Platform" />
                        <PropertyColumn Property="x => x.releasedates" Title="Release Date" />
                        <PropertyColumn Property="x => x.aggregatedrating" Title="Rating" />
                        <PropertyColumn Property="x => x.genres" Title="Genres" />
                        <PropertyColumn Property="x => x.status" Title="Status">
                            <CellTemplate Context="gameContext">
                                <MudSelect T="string" 
                                          Value="@gameContext.Item.status" 
                                          ValueChanged="@(value => UpdateGameStatus(gameContext.Item, value))"
                                          Dense="true"
                                          Margin="Margin.Dense"
                                          OffsetY="true">
                                    @foreach(var status in GameStatuses)
                                    {
                                        <MudSelectItem Value="@status">@status</MudSelectItem>
                                    }
                                </MudSelect>
                            </CellTemplate>
                        </PropertyColumn>
                        <TemplateColumn Title="Actions">
                            <CellTemplate Context="gameContext">
                                <div class="d-flex gap-2">
                                    <MudButton Variant="Variant.Filled" 
                                              Color="Color.Primary" 
                                              Size="Size.Small"
                                              OnClick="@(() => AddToQueue(gameContext.Item))"
                                              Disabled="@(gameContext.Item.queuepos != null || _processing)"
                                              Loading="@(_processingId == gameContext.Item.id)"
                                              Class="fixed-width-button"> 
                                        @GetQueueButtonText(gameContext.Item)
                                    </MudButton>

                                    <MudIconButton Icon="@Icons.Material.Filled.Edit" 
                                              Variant="Variant.Filled" 
                                              Color="Color.Info" 
                                              Size="Size.Small"
                                              aria-label="edit"
                                              OnClick="@(() => OpenEditGameDialog(gameContext.Item))">
                                    </MudIconButton>

                                    <MudIconButton Icon="@Icons.Material.Filled.DeleteForever" 
                                              Variant="Variant.Filled" 
                                              Color="Color.Error" 
                                              Size="Size.Small"
                                              aria-label="delete"
                                              OnClick="@(() => DeleteGameWithConfirmation(gameContext.Item))"
                                              Loading="@(_deletingId == gameContext.Item.id)">
                                    </MudIconButton>
                                </div>
                            </CellTemplate>
                        </TemplateColumn>
                    </Columns>
                </MudDataGrid>
                
                @if (_loadingMoreGames)
                {
                    <div class="loading-indicator">
                        <MudProgressCircular Color="Color.Primary" Indeterminate="true" Size="Size.Small" />
                        <MudText Class="ml-2" Typo="Typo.body2">Loading more games...</MudText>
                    </div>
                }
                
                @if (!_hasMoreGames && DisplayedGames.Any())
                {
                    <div class="end-indicator">
                        <MudText Typo="Typo.body2" Color="Color.Secondary">
                            Showing @DisplayedGames.Count() of @FilteredGames.Count() games
                        </MudText>
                    </div>
                }
            </div>
        </MudTabPanel>

        <MudTabPanel Text="Queue" Class="full-height-panel">
            <div id="queue-scroll-container" class="infinite-scroll-container">
                <MudDataGrid Items="@DisplayedQueueGames" 
                             Dense="true" 
                             Hover="true" 
                             Bordered="true" 
                             Striped="true"
                             RowsDraggable="true"
                             DragDropColumn="0"
                             RowDrop="OnRowDrop"
                             Virtualize="false"
                             FixedHeader="true"
                             Height="100%"
                             Class="data-grid-with-fixed-header">
                    <ToolBarContent>
                        <MudText Typo="Typo.h6">Game Queue (@queueGames.Count total)</MudText>
                        <MudSpacer />
                        <MudTextField @bind-Value="queueSearchString" 
                                     Placeholder="Search" 
                                     Adornment="Adornment.Start"
                                     AdornmentIcon="@Icons.Material.Filled.Search" 
                                     IconSize="Size.Medium" 
                                     Class="mt-0"
                                     Immediate="true"
                                     @bind-Value:after="OnQueueSearchChanged" />
                    </ToolBarContent>
                    <Columns>
                        <PropertyColumn Property="x => x.queuepos" Title="#" />
                        <PropertyColumn Property="x => x.name" Title="Title" />
                        <PropertyColumn Property="x => x.platforms" Title="Platform" />
                        <PropertyColumn Property="x => x.releasedates" Title="Release Date" />
                        <PropertyColumn Property="x => x.aggregatedrating" Title="Rating" />
                        <PropertyColumn Property="x => x.status" Title="Status">
                            <CellTemplate Context="gameContext">
                                <MudSelect T="string" 
                                          Value="@gameContext.Item.status" 
                                          ValueChanged="@(value => UpdateGameStatus(gameContext.Item, value))"
                                          Dense="true"
                                          Margin="Margin.Dense"
                                          OffsetY="true">
                                    @foreach(var status in GameStatuses)
                                    {
                                        <MudSelectItem Value="@status">@status</MudSelectItem>
                                    }
                                </MudSelect>
                            </CellTemplate>
                        </PropertyColumn>
                        <TemplateColumn Title="Actions">
                            <CellTemplate Context="gameContext">
                                <div class="d-flex gap-2">
                                    <MudButton Variant="Variant.Filled" 
                                              Color="Color.Primary" 
                                              Size="Size.Small"
                                              OnClick="@(() => RemoveFromQueue(gameContext.Item))"
                                              Disabled="@(gameContext.Item.queuepos == null || _processing)"
                                              Loading="@(_processingId == gameContext.Item.id)"
                                              Class="fixed-width-queue-button">
                                        @(_processingId == gameContext.Item.id ? "Removing..." : "Remove From Queue")
                                    </MudButton>

                                    <MudIconButton Icon="@Icons.Material.Filled.Edit" 
                                              Variant="Variant.Filled" 
                                              Color="Color.Info" 
                                              Size="Size.Small"
                                              aria-label="edit"
                                              OnClick="@(() => OpenEditGameDialog(gameContext.Item))">
                                    </MudIconButton>
                                </div>
                            </CellTemplate>
                        </TemplateColumn>
                    </Columns>
                </MudDataGrid>
                
                @if (_loadingMoreQueueGames)
                {
                    <div class="loading-indicator">
                        <MudProgressCircular Color="Color.Primary" Indeterminate="true" Size="Size.Small" />
                        <MudText Class="ml-2" Typo="Typo.body2">Loading more games...</MudText>
                    </div>
                }
                
                @if (!_hasMoreQueueGames && DisplayedQueueGames.Any())
                {
                    <div class="end-indicator">
                        <MudText Typo="Typo.body2" Color="Color.Secondary">
                            Showing @DisplayedQueueGames.Count() of @FilteredQueueGames.Count() games
                        </MudText>
                    </div>
                }
            </div>
        </MudTabPanel>
    </MudTabs>
</div>

<style>
    .full-height-container {
        height: calc(100vh - 4.6rem);
        display: flex;
        flex-direction: column;
    }

    .full-height-tabs {
        height: 100%;
        display: flex;
        flex-direction: column;
    }

    .full-height-tabs .mud-tabs-panels {
        flex: 1;
        min-height: 0;
        overflow: hidden;
        display: flex;
        flex-direction: column;
    }

    .full-height-panel {
        height: 100% !important;
        display: flex !important;
        flex-direction: column !important;
        min-height: 0;
        overflow: hidden;
        box-sizing: border-box;
    }

    .infinite-scroll-container {
        flex: 1 1 0;
        min-height: 0;
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }

    .data-grid-with-fixed-header {
        flex: 1;
        min-height: 0;
        display: flex;
        flex-direction: column;
    }

    .data-grid-with-fixed-header .mud-table-container {
        flex: 1;
        min-height: 0;
        max-height: calc(100vh - 300px);
        overflow-y: auto !important;
        overflow-x: auto;
    }

    .loading-indicator, .end-indicator {
        flex-shrink: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 16px;
    }

    .mud-grid-item.mud-dragging {
        background-color: var(--mud-palette-background-grey);
        opacity: 0.8;
    }

    .fixed-width-button {
        width: 130px;
    }
    
    .fixed-width-queue-button {
        width: 170px;
    }
</style>

@code {
    // Constants
    private const int PageSize = 20;
    private const int InitialRenderDelayMs = 2000;
    private static readonly string[] GameStatuses = { "Not Started", "Playing", "Completed", "Dropped" };

    // State
    private string searchString = "";
    private string queueSearchString = "";
    private List<GameDAO> games = new();
    private List<GameDAO> queueGames = new();
    
    private bool _processing;
    private int _processingId = -1;
    private int _deletingId = -1;
    private string? _user;

    // Pagination
    private int _currentGamesPage = 1;
    private int _currentQueuePage = 1;
    private bool _loadingMoreGames;
    private bool _loadingMoreQueueGames;
    private bool _hasMoreGames = true;
    private bool _hasMoreQueueGames = true;
    
    // Infrastructure
    private DotNetObjectReference<Index>? _objRef;
    private int _activeTabIndex;
    private bool _scrollSetupComplete;

    // Computed Properties
    private IEnumerable<GameDAO> FilteredGames => 
        string.IsNullOrWhiteSpace(searchString) 
            ? games 
            : games.Where(x => x.name?.Contains(searchString, StringComparison.OrdinalIgnoreCase) == true);

    private IEnumerable<GameDAO> FilteredQueueGames => 
        string.IsNullOrWhiteSpace(queueSearchString) 
            ? queueGames 
            : queueGames.Where(x => x.name?.Contains(queueSearchString, StringComparison.OrdinalIgnoreCase) == true);

    private IEnumerable<GameDAO> DisplayedGames => FilteredGames.Take(_currentGamesPage * PageSize);
    private IEnumerable<GameDAO> DisplayedQueueGames => FilteredQueueGames.Take(_currentQueuePage * PageSize);

    // Lifecycle Methods
    protected override async Task OnInitializedAsync()
    {
        _user = await GetAuthenticatedUserAsync();
        _objRef = DotNetObjectReference.Create(this);
        await LoadGamesAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_scrollSetupComplete || _objRef == null) return;
        
        _scrollSetupComplete = true;
        await Task.Delay(InitialRenderDelayMs);
        
        try
        {
            await JSRuntime.InvokeVoidAsync("setupInfiniteScrollById", "games-scroll-container", _objRef, "LoadMoreGames");
            await JSRuntime.InvokeVoidAsync("setupInfiniteScrollById", "queue-scroll-container", _objRef, "LoadMoreQueueGames");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error setting up infinite scroll: {ex.Message}");
        }
    }

    // Data Loading
    private async Task<string> GetAuthenticatedUserAsync()
    {
        var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        return authState.User.FindFirst(JwtRegisteredClaimNames.UniqueName)?.Value
               ?? authState.User.Identity?.Name
               ?? "unknown";
    }

    private async Task LoadGamesAsync()
    {
        try
        {
            games = await Http.GetFromJsonAsync<List<GameDAO>>($"api/GameCollection/GetCollection/{_user}") ?? new();
            queueGames = games.Where(g => g.queuepos != null).OrderBy(g => g.queuepos).ToList();
            ResetPagination();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading games: {ex.Message}");
            Snackbar.Add("Failed to load games", Severity.Error);
            games = new();
            queueGames = new();
        }
    }

    private void ResetPagination()
    {
        _currentGamesPage = 1;
        _currentQueuePage = 1;
        _hasMoreGames = FilteredGames.Count() > PageSize;
        _hasMoreQueueGames = FilteredQueueGames.Count() > PageSize;
    }

    // Infinite Scroll Callbacks
    [JSInvokable]
    public async Task LoadMoreGames()
    {
        if (_loadingMoreGames || !_hasMoreGames) return;

        _loadingMoreGames = true;
        StateHasChanged();
        await Task.Delay(300);

        var totalFiltered = FilteredGames.Count();
        if (_currentGamesPage * PageSize < totalFiltered)
        {
            _currentGamesPage++;
            _hasMoreGames = (_currentGamesPage * PageSize) < totalFiltered;
        }
        else
        {
            _hasMoreGames = false;
        }

        _loadingMoreGames = false;
        StateHasChanged();
    }

    [JSInvokable]
    public async Task LoadMoreQueueGames()
    {
        if (_loadingMoreQueueGames || !_hasMoreQueueGames) return;

        _loadingMoreQueueGames = true;
        StateHasChanged();
        await Task.Delay(300);

        var totalFiltered = FilteredQueueGames.Count();
        if (_currentQueuePage * PageSize < totalFiltered)
        {
            _currentQueuePage++;
            _hasMoreQueueGames = (_currentQueuePage * PageSize) < totalFiltered;
        }
        else
        {
            _hasMoreQueueGames = false;
        }

        _loadingMoreQueueGames = false;
        StateHasChanged();
    }

    // Dialog Operations
    private async Task OpenAddGameDialog()
    {
        var dialog = await DialogService.ShowAsync<AddGameDialog>("Add New Game");
        var result = await dialog.Result;

        if (!result.Canceled && result.Data is GameDAO gameDao)
        {
            gameDao.owner = _user;
            gameDao.status = "Not Started";
            await ExecuteApiCallAsync(
                () => Http.PostAsJsonAsync($"api/GameCollection/AddNewGame?user={_user}", gameDao),
                $"Added {gameDao.name} to collection",
                "Failed to add game");
        }
    }

    private async Task OpenEditGameDialog(GameDAO game)
    {
        var parameters = new DialogParameters { { "Game", game } };
        var dialog = await DialogService.ShowAsync<EditGameDialog>("Edit Game", parameters);
        var result = await dialog.Result;

        if (!result.Canceled && result.Data is GameDAO editedGame)
        {
            editedGame.owner = _user;
            await ExecuteApiCallAsync(
                () => Http.PostAsJsonAsync($"api/GameCollection/AddNewGame?user={_user}", editedGame),
                $"Updated {editedGame.name} successfully",
                "Failed to update game");
        }
    }

    private async Task DeleteGameWithConfirmation(GameDAO game)
    {
        var confirmed = await DialogService.ShowMessageBox(
            "Delete Game",
            $"Are you sure you want to delete {game.name}?",
            yesText: "Delete",
            cancelText: "Cancel",
            options: new DialogOptions { CloseOnEscapeKey = true });

        if (confirmed != true) return;

        _deletingId = game.id;
        StateHasChanged();

        try
        {
            if (game.queuepos != null)
            {
                await RemoveFromQueue(game);
            }

            await ExecuteApiCallAsync(
                () => Http.PostAsJsonAsync($"api/GameCollection/DeleteGame?user={_user}", game),
                $"{game.name} deleted successfully",
                $"Failed to delete {game.name}");
        }
        finally
        {
            _deletingId = -1;
            StateHasChanged();
        }
    }

    // Game Operations
    private async Task AddToQueue(GameDAO game) =>
        await ExecuteWithProcessingStateAsync(
            game.id,
            () => Http.PostAsJsonAsync($"api/GameCollection/AddToQueue?user={_user}", game),
            $"{game.name} added to queue",
            $"Failed to add {game.name} to queue");

    private async Task RemoveFromQueue(GameDAO game) =>
        await ExecuteWithProcessingStateAsync(
            game.id,
            () => Http.PostAsJsonAsync($"api/GameCollection/RemoveFromQueue?user={_user}", game),
            $"{game.name} removed from queue",
            $"Failed to remove {game.name} from queue");

    private async Task UpdateGameStatus(GameDAO game, string newStatus)
    {
        game.status = newStatus;
        await ExecuteApiCallAsync(
            () => Http.PostAsJsonAsync($"api/GameCollection/AddNewGame?user={_user}", game),
            $"Updated status for {game.name} to {newStatus}",
            "Failed to update game status");
    }

    private async Task OnRowDrop(MudItemDropInfo<GameDAO> dropInfo)
    {
        if (dropInfo.Item == null) return;
        
        var oldIndex = queueGames.IndexOf(dropInfo.Item);
        var newIndex = dropInfo.IndexInZone;
        
        if (oldIndex == newIndex) return;
        
        queueGames.RemoveAt(oldIndex);
        queueGames.Insert(newIndex, dropInfo.Item);
        
        for (int i = 0; i < queueGames.Count; i++)
        {
            queueGames[i].queuepos = i + 1;
        }
        
        try
        {
            await Task.WhenAll(queueGames.Select(g => 
                Http.PostAsJsonAsync($"api/GameCollection/AddNewGame?user={_user}", g)));
            Snackbar.Add("Queue order updated", Severity.Success);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error updating queue order: {ex.Message}");
            Snackbar.Add("Error updating queue order", Severity.Error);
            await LoadGamesAsync();
        }
    }

    // Search Handlers
    private async Task OnSearchChanged()
    {
        _currentGamesPage = 1;
        _hasMoreGames = FilteredGames.Count() > PageSize;
        await InvokeAsync(StateHasChanged);
    }

    private async Task OnQueueSearchChanged()
    {
        _currentQueuePage = 1;
        _hasMoreQueueGames = FilteredQueueGames.Count() > PageSize;
        await InvokeAsync(StateHasChanged);
    }

    // Helper Methods
    private string GetQueueButtonText(GameDAO game)
    {
        if (_processingId == game.id) return "Adding...";
        if (game.queuepos != null) return "In Queue";
        return "Add to Queue";
    }

    private async Task ExecuteWithProcessingStateAsync(
        int gameId, 
        Func<Task<HttpResponseMessage>> apiCall, 
        string successMessage, 
        string errorMessage)
    {
        _processing = true;
        _processingId = gameId;
        StateHasChanged();

        try
        {
            await ExecuteApiCallAsync(apiCall, successMessage, errorMessage);
        }
        finally
        {
            _processing = false;
            _processingId = -1;
            StateHasChanged();
        }
    }

    private async Task ExecuteApiCallAsync(
        Func<Task<HttpResponseMessage>> apiCall, 
        string successMessage, 
        string errorMessage)
    {
        try
        {
            var response = await apiCall();
            
            if (response.IsSuccessStatusCode)
            {
                Snackbar.Add(successMessage, Severity.Success);
                await LoadGamesAsync();
            }
            else
            {
                var error = await response.Content.ReadAsStringAsync();
                Console.WriteLine($"Error response: {error}");
                Snackbar.Add(errorMessage, Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error: {ex.Message}");
            Snackbar.Add($"{errorMessage}: {ex.Message}", Severity.Error);
        }
    }

    // Cleanup
    public async ValueTask DisposeAsync()
    {
        if (_objRef != null)
        {
            try
            {
                await JSRuntime.InvokeVoidAsync("disposeAllInfiniteScroll");
            }
            catch
            {
                // JavaScript interop may fail during disposal
            }
            
            _objRef.Dispose();
        }
    }
}